{"version":3,"sources":["../node_modules/immer/dist/immer.module.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/process/browser.js"],"names":["process","obj","NOTHING","Symbol","DRAFTABLE","for","DRAFT_STATE","isDraft","value","isDraftable","Array","isArray","proto","Object","getPrototypeOf","prototype","isPlainObject","constructor","isMap","isSet","original","base","assign","target","overrides","len","arguments","length","forEach","override","keys","key","ownKeys","Reflect","getOwnPropertySymbols","getOwnPropertyNames","concat","shallowCopy","invokeGetters","slice","Map","Set","clone","create","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","writable","configurable","each","iter","entry","index","isEnumerable","prop","has","thing","hasOwnProperty","is","x","y","hasSymbol","hasMap","hasSet","makeIterable","next","self","iterator","iterateMapValues","state","receiver","isEntries","latest","result","done","makeIterateSetValues","createProxy","draft","drafts","finalized","finalizing","set","modified","copy","add","wrapSetValue","map","cloned","freeze","deep","isFrozen","clear","delete","dontMutateFrozenCollections","_","ImmerScope","parent","this","canAutoFreeze","patches","revoke","clonePotentialDraft","defineProperties","mapTraps","proxyMethod","setTraps","iterateSetValues","proxySet","descriptors","assertUnrevoked","peek","latest$1","prepareCopy","get$1","assigned","markChanged","proxyProperty","scope","current","revoke$1","revoked","createHiddenProperty","push","usePatches","patchListener","inversePatches","leave","enter","finalizeTraps","size","i","list","reciever","cb","values","entries","thisArg","traps","reduce","acc","builder","proxyAttr","fn","trap","args","apply","JSON","stringify","markChangesSweep","hasArrayChanges","hasMapChanges","hasSetChanges","hasObjectChanges","baseValue","undefined","state$1","descriptor","hasChanges","obj$1","obj$1$1","legacyProxy","willFinalize","isReplaced","markChangesRecursively","object","i$1","i$2","createProxy$1","objectTraps","arrayTraps","mapTraps$1","setTraps$1","ref","Proxy","revocable","proxy","latest$2","peek$1","markChanged$1","deleteProperty","owner","setPrototypeOf","isNaN","parseInt","reflectTraps","name","makeTrapsForGetters","iterateSetValues$1","prev","assignMap","getters","modernProxy","generateArrayPatches","basePath","assign$1","delta","start","end","path","op","replaceCount","path$1","generatePatchesFromAssigned","assignedValue","origValue","generateSetPatches","unshift","list$1","value$1","applyPatches","patch","join","splice","configDefaults","useProxies","autoFreeze","onAssign","onDelete","onCopy","Immer","config","setUseProxies","produce","bind","produceWithPatches","recipe","this$1","defaultBase","hasError","Promise","then","processResult","error","maybeFreeze","arg1","arg2","arg3","p","ip","createDraft","isManual","finishDraft","setAutoFreeze","baseDraft","finalize","finalizeTree","exists","generatePatches","root","rootPath","needPatches","finalizeProperty","isDraftProp","isSetMember","replace","immer","__webpack_exports__","_slicedToArray","arr","_arrayWithHoles","_arr","_n","_d","_e","_s","_i","err","_iterableToArrayLimit","TypeError","_nonIterableRest","__webpack_require__","d","cachedSetTimeout","cachedClearTimeout","module","exports","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","nextTick","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"static/js/8.5ee918f6.chunk.js","sourcesContent":["var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : (obj = {}, obj[\"immer-nothing\"] = true, obj);\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n\nfunction isDraftable(value) {\n  if (!value) {\n    return false;\n  }\n\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n} // We use Maps as `drafts` for Sets, not Objects\n// See proxy.js\n\n\nfunction assignSet(target, override) {\n  override.forEach(function (value) {\n    // When we add new drafts we have to remove their originals if present\n    var prev = original(value);\n\n    if (prev) {\n      target.delete(prev);\n    }\n\n    target.add(value);\n  });\n  return target;\n} // We use Maps as `drafts` for Maps, not Objects\n// See proxy.js\n\n\nfunction assignMap(target, override) {\n  override.forEach(function (value, key) {\n    return target.set(key, value);\n  });\n  return target;\n}\n\nvar assign = Object.assign || function (target) {\n  var overrides = [],\n      len = arguments.length - 1;\n\n  while (len-- > 0) {\n    overrides[len] = arguments[len + 1];\n  }\n\n  overrides.forEach(function (override) {\n    return Object.keys(override).forEach(function (key) {\n      return target[key] = override[key];\n    });\n  });\n  return target;\n};\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : Object.getOwnPropertyNames;\n\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) invokeGetters = false;\n\n  if (Array.isArray(base)) {\n    return base.slice();\n  }\n\n  if (isMap(base)) {\n    return new Map(base);\n  }\n\n  if (isSet(base)) {\n    return new Set(base);\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\n\nfunction each(obj, iter) {\n  if (Array.isArray(obj) || isMap(obj) || isSet(obj)) {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  } else {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  }\n}\n\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\n\nfunction has(thing, prop) {\n  return isMap(thing) ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction get(thing, prop) {\n  return isMap(thing) ? thing.get(prop) : thing[prop];\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\n\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\n\nvar hasSet = typeof Set !== \"undefined\";\n\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\n\nfunction makeIterable(next) {\n  var obj;\n  var self;\n  return self = (obj = {}, obj[Symbol.iterator] = function () {\n    return self;\n  }, obj.next = next, obj);\n}\n/** Map.prototype.values _-or-_ Map.prototype.entries */\n\n\nfunction iterateMapValues(state, prop, receiver) {\n  var isEntries = prop !== \"values\";\n  return function () {\n    var iterator = latest(state)[Symbol.iterator]();\n    return makeIterable(function () {\n      var result = iterator.next();\n\n      if (!result.done) {\n        var ref = result.value;\n        var key = ref[0];\n        var value = receiver.get(key);\n        result.value = isEntries ? [key, value] : value;\n      }\n\n      return result;\n    });\n  };\n}\n\nfunction makeIterateSetValues(createProxy) {\n  function iterateSetValues(state, prop) {\n    var isEntries = prop === \"entries\";\n    return function () {\n      var iterator = latest(state)[Symbol.iterator]();\n      return makeIterable(function () {\n        var result = iterator.next();\n\n        if (!result.done) {\n          var value = wrapSetValue(state, result.value);\n          result.value = isEntries ? [value, value] : value;\n        }\n\n        return result;\n      });\n    };\n  }\n\n  function wrapSetValue(state, value) {\n    var key = original(value) || value;\n    var draft = state.drafts.get(key);\n\n    if (!draft) {\n      if (state.finalized || !isDraftable(value) || state.finalizing) {\n        return value;\n      }\n\n      draft = createProxy(value, state);\n      state.drafts.set(key, draft);\n\n      if (state.modified) {\n        state.copy.add(draft);\n      }\n    }\n\n    return draft;\n  }\n\n  return iterateSetValues;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  if (isMap(obj)) {\n    return new Map(obj);\n  }\n\n  if (isSet(obj)) {\n    return new Set(obj);\n  }\n\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) {\n    cloned[key] = clone(obj[key]);\n  }\n\n  return cloned;\n}\n\nfunction freeze(obj, deep) {\n  if (deep === void 0) deep = false;\n\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) {\n    return;\n  }\n\n  if (isSet(obj)) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (isMap(obj)) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n\n  if (deep) {\n    each(obj, function (_, value) {\n      return freeze(value, true);\n    });\n  }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n/** Each scope represents a `produce` call. */\n\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches(patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1() {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave() {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\n\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\n\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n\n  if (isMap(base)) {\n    proxyMap(draft);\n  } else if (isSet(base)) {\n    proxySet(draft);\n  } else {\n    each(draft, function (prop) {\n      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n    });\n  } // See \"proxy.js\" for property documentation.\n\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: isMap(base) ? new Map() : {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    drafts: isSet(base) ? new Map() : null,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction latest$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(latest$1(state), prop);\n\n  if (state.finalizing) {\n    return value;\n  } // Create a draft if the value is unmodified.\n\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(latest$1(state), prop))) {\n      return;\n    }\n\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = clonePotentialDraft(state.base);\n  }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function get$1$1() {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction proxyMap(target) {\n  Object.defineProperties(target, mapTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateMapValues));\n  }\n}\n\nvar mapTraps = finalizeTraps({\n  size: function size(state) {\n    return latest$1(state).size;\n  },\n  has: function has(state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  set: function set(state) {\n    return function (key, value) {\n      if (latest$1(state).get(key) !== value) {\n        prepareCopy(state);\n        markChanged(state);\n        state.assigned.set(key, true);\n        state.copy.set(key, value);\n      }\n\n      return state.draft;\n    };\n  },\n  delete: function _delete(state) {\n    return function (key) {\n      prepareCopy(state);\n      markChanged(state);\n      state.assigned.set(key, false);\n      state.copy.delete(key);\n      return false;\n    };\n  },\n  clear: function clear(state) {\n    return function () {\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      markChanged(state);\n      state.assigned = new Map();\n\n      for (var i = 0, list = latest$1(state).keys(); i < list.length; i += 1) {\n        var key = list[i];\n        state.assigned.set(key, false);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  forEach: function forEach(state, key, reciever) {\n    return function (cb) {\n      latest$1(state).forEach(function (value, key, map) {\n        cb(reciever.get(key), key, map);\n      });\n    };\n  },\n  get: function get(state) {\n    return function (key) {\n      var value = latest$1(state).get(key);\n\n      if (state.finalizing || state.finalized || !isDraftable(value)) {\n        return value;\n      }\n\n      if (value !== state.base.get(key)) {\n        return value;\n      }\n\n      var draft = createProxy(value, state);\n      prepareCopy(state);\n      state.copy.set(key, draft);\n      return draft;\n    };\n  },\n  keys: function keys(state) {\n    return function () {\n      return latest$1(state).keys();\n    };\n  },\n  values: iterateMapValues,\n  entries: iterateMapValues\n});\n\nfunction proxySet(target) {\n  Object.defineProperties(target, setTraps);\n\n  if (hasSymbol) {\n    Object.defineProperty(target, Symbol.iterator, proxyMethod(iterateSetValues));\n  }\n}\n\nvar iterateSetValues = makeIterateSetValues(createProxy);\nvar setTraps = finalizeTraps({\n  size: function size(state) {\n    return latest$1(state).size;\n  },\n  add: function add(state) {\n    return function (value) {\n      if (!latest$1(state).has(value)) {\n        markChanged(state);\n\n        if (!state.copy) {\n          prepareCopy(state);\n        }\n\n        state.copy.add(value);\n      }\n\n      return state.draft;\n    };\n  },\n  delete: function _delete(state) {\n    return function (value) {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy.delete(value);\n    };\n  },\n  has: function has(state) {\n    return function (key) {\n      return latest$1(state).has(key);\n    };\n  },\n  clear: function clear(state) {\n    return function () {\n      markChanged(state);\n\n      if (!state.copy) {\n        prepareCopy(state);\n      }\n\n      return state.copy.clear();\n    };\n  },\n  keys: iterateSetValues,\n  entries: iterateSetValues,\n  values: iterateSetValues,\n  forEach: function forEach(state) {\n    return function (cb, thisArg) {\n      var iterator = iterateSetValues(state)();\n      var result = iterator.next();\n\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, state.draft);\n        result = iterator.next();\n      }\n    };\n  }\n});\n\nfunction finalizeTraps(traps) {\n  return Object.keys(traps).reduce(function (acc, key) {\n    var builder = key === \"size\" ? proxyAttr : proxyMethod;\n    acc[key] = builder(traps[key], key);\n    return acc;\n  }, {});\n}\n\nfunction proxyAttr(fn) {\n  return {\n    get: function get() {\n      var state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      return fn(state);\n    }\n  };\n}\n\nfunction proxyMethod(trap, key) {\n  return {\n    get: function get() {\n      return function () {\n        var args = [],\n            len = arguments.length;\n\n        while (len--) {\n          args[len] = arguments[len];\n        }\n\n        var state = this[DRAFT_STATE];\n        assertUnrevoked(state);\n        return trap(state, key, state.draft).apply(void 0, args);\n      };\n    }\n  };\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) {\n    throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest$1(state)));\n  }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) {\n          markChanged(state);\n        }\n      } else if (isMap(state.base)) {\n        if (hasMapChanges(state)) {\n          markChanged(state);\n        }\n      } else if (isSet(state.base)) {\n        if (hasSetChanges(state)) {\n          markChanged(state);\n        }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") {\n    return;\n  }\n\n  var state = object[DRAFT_STATE];\n\n  if (!state) {\n    return;\n  }\n\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) {\n        assigned[i$1] = true;\n      }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) {\n        markChangesRecursively(draft[i$2]);\n      }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n\n  if (draft.length !== state.base.length) {\n    return true;\n  } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) {\n    return true;\n  } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n\n  return false;\n}\n\nfunction hasMapChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n\n  if (base.size !== draft.size) {\n    return true;\n  } // IE11 supports only forEach iteration\n\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : value !== base.get(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction hasSetChanges(state) {\n  var base = state.base;\n  var draft = state.draft;\n\n  if (base.size !== draft.size) {\n    return true;\n  } // IE11 supports only forEach iteration\n\n\n  var hasChanges = false;\n  draft.forEach(function (value, key) {\n    if (!hasChanges) {\n      hasChanges = isDraftable(value) ? value.modified : !base.has(key);\n    }\n  });\n  return hasChanges;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy =\n/*#__PURE__*/\nObject.freeze({\n  willFinalize: willFinalize,\n  createProxy: createProxy\n});\nvar obj$1, obj$1$1;\n\nfunction willFinalize$1() {}\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\n\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var target = state;\n  var traps = objectTraps;\n\n  if (Array.isArray(base)) {\n    target = [state];\n    traps = arrayTraps;\n  } // Map drafts must support object keys, so we use Map objects to track changes.\n  else if (isMap(base)) {\n      traps = mapTraps$1;\n      state.drafts = new Map();\n      state.assigned = new Map();\n    } // Set drafts use a Map object to track which of its values are drafted.\n    // And we don't need the \"assigned\" property, because Set objects have no keys.\n    else if (isSet(base)) {\n        traps = setTraps$1;\n        state.drafts = new Map();\n      }\n\n  var ref = Proxy.revocable(target, traps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n/**\n * Object drafts\n */\n\n\nvar objectTraps = {\n  get: function get(state, prop) {\n    if (prop === DRAFT_STATE) {\n      return state;\n    }\n\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest$2(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek$1(state.base, prop)) {\n        return value;\n      } // Store drafts on the copy (when one exists).\n\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = createProxy$1(value, state);\n  },\n  has: function has(state, prop) {\n    return prop in latest$2(state);\n  },\n  ownKeys: function ownKeys(state) {\n    return Reflect.ownKeys(latest$2(state));\n  },\n  set: function set(state, prop, value) {\n    if (!state.modified) {\n      var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n\n      if (isUnchanged) {\n        return true;\n      }\n\n      markChanged$1(state);\n    }\n\n    state.assigned[prop] = true;\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      markChanged$1(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    }\n\n    if (state.copy) {\n      delete state.copy[prop];\n    }\n\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\n    var owner = latest$2(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n    }\n\n    return desc;\n  },\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function getPrototypeOf(state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\n * Array drafts\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // Used by Map and Set drafts\n\n\nvar reflectTraps = makeReflectTraps([\"ownKeys\", \"has\", \"set\", \"deleteProperty\", \"defineProperty\", \"getOwnPropertyDescriptor\", \"preventExtensions\", \"isExtensible\", \"getPrototypeOf\"]);\n/**\n * Map drafts\n */\n\nvar mapTraps$1 = makeTrapsForGetters((obj$1 = {}, obj$1[DRAFT_STATE] = function (state) {\n  return state;\n}, obj$1.size = function (state) {\n  return latest$2(state).size;\n}, obj$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, obj$1.set = function (state) {\n  return function (key, value) {\n    var values = latest$2(state);\n\n    if (!values.has(key) || values.get(key) !== value) {\n      markChanged$1(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n    }\n\n    return state.draft;\n  };\n}, obj$1.delete = function (state) {\n  return function (key) {\n    if (latest$2(state).has(key)) {\n      markChanged$1(state);\n      state.assigned.set(key, false);\n      return state.copy.delete(key);\n    }\n\n    return false;\n  };\n}, obj$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    state.assigned = new Map();\n\n    for (var i = 0, list = latest$2(state).keys(); i < list.length; i += 1) {\n      var key = list[i];\n      state.assigned.set(key, false);\n    }\n\n    return state.copy.clear();\n  };\n}, obj$1.forEach = function (state, _, receiver) {\n  return function (cb, thisArg) {\n    return latest$2(state).forEach(function (_, key, map) {\n      var value = receiver.get(key);\n      cb.call(thisArg, value, key, map);\n    });\n  };\n}, obj$1.get = function (state) {\n  return function (key) {\n    var drafts = state[state.modified ? \"copy\" : \"drafts\"];\n\n    if (drafts.has(key)) {\n      return drafts.get(key);\n    }\n\n    var value = latest$2(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    var draft = createProxy$1(value, state);\n    drafts.set(key, draft);\n    return draft;\n  };\n}, obj$1.keys = function (state) {\n  return function () {\n    return latest$2(state).keys();\n  };\n}, obj$1.values = iterateMapValues, obj$1.entries = iterateMapValues, obj$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateMapValues, obj$1));\nvar iterateSetValues$1 = makeIterateSetValues(createProxy$1);\n/**\n * Set drafts\n */\n\nvar setTraps$1 = makeTrapsForGetters((obj$1$1 = {}, obj$1$1[DRAFT_STATE] = function (state) {\n  return state;\n}, obj$1$1.size = function (state) {\n  return latest$2(state).size;\n}, obj$1$1.has = function (state) {\n  return function (key) {\n    return latest$2(state).has(key);\n  };\n}, obj$1$1.add = function (state) {\n  return function (value) {\n    if (!latest$2(state).has(value)) {\n      markChanged$1(state);\n      state.copy.add(value);\n    }\n\n    return state.draft;\n  };\n}, obj$1$1.delete = function (state) {\n  return function (value) {\n    markChanged$1(state);\n    return state.copy.delete(value);\n  };\n}, obj$1$1.clear = function (state) {\n  return function () {\n    markChanged$1(state);\n    return state.copy.clear();\n  };\n}, obj$1$1.forEach = function (state) {\n  return function (cb, thisArg) {\n    var iterator = iterateSetValues$1(state)();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, state.draft);\n      result = iterator.next();\n    }\n  };\n}, obj$1$1.keys = iterateSetValues$1, obj$1$1.values = iterateSetValues$1, obj$1$1.entries = iterateSetValues$1, obj$1$1[hasSymbol ? Symbol.iterator : \"@@iterator\"] = iterateSetValues$1, obj$1$1));\n/**\n * Helpers\n */\n// Retrieve the latest values of the draft.\n\nfunction latest$2(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest$2(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    var base = state.base;\n    var drafts = state.drafts;\n    var parent = state.parent;\n    var copy = shallowCopy(base);\n\n    if (isSet(base)) {\n      // Note: The `drafts` property is preserved for Set objects, since\n      // we need to keep track of which values are drafted.\n      assignSet(copy, drafts);\n    } else {\n      // Merge nested drafts into the copy.\n      if (isMap(base)) {\n        assignMap(copy, drafts);\n      } else {\n        assign(copy, drafts);\n      }\n\n      state.drafts = null;\n    }\n\n    state.copy = copy;\n\n    if (parent) {\n      markChanged$1(parent);\n    }\n  }\n}\n/** Create traps that all use the `Reflect` API on the `latest(state)` */\n\n\nfunction makeReflectTraps(names) {\n  return names.reduce(function (traps, name) {\n    traps[name] = function (state) {\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        args[len] = arguments[len + 1];\n      }\n\n      return Reflect[name].apply(Reflect, [latest$2(state)].concat(args));\n    };\n\n    return traps;\n  }, {});\n}\n\nfunction makeTrapsForGetters(getters) {\n  return Object.assign({}, reflectTraps, {\n    get: function get(state, prop, receiver) {\n      return getters.hasOwnProperty(prop) ? getters[prop](state, prop, receiver) : Reflect.get(state, prop, receiver);\n    },\n    setPrototypeOf: function setPrototypeOf(state) {\n      throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n    }\n  });\n}\n\nvar modernProxy =\n/*#__PURE__*/\nObject.freeze({\n  willFinalize: willFinalize$1,\n  createProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  var generatePatchesFn = Array.isArray(state.base) ? generateArrayPatches : isSet(state.base) ? generateSetPatches : generatePatchesFromAssigned;\n  generatePatchesFn(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    assign = [copy, base], base = assign[0], copy = assign[1];\n    assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n\n    if (origValue === value && op === \"replace\") {\n      return;\n    }\n\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  var i = 0;\n\n  for (var i$1 = 0, list = base; i$1 < list.length; i$1 += 1) {\n    var value = list[i$1];\n\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  }\n\n  i = 0;\n\n  for (var i$2 = 0, list$1 = copy; i$2 < list$1.length; i$2 += 1) {\n    var value$1 = list$1[i$2];\n\n    if (!base.has(value$1)) {\n      var path$1 = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path$1,\n        value: value$1\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path$1,\n        value: value$1\n      });\n    }\n\n    i++;\n  }\n}\n\nvar applyPatches = function applyPatches(draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n    var path = patch.path;\n    var op = patch.op;\n\n    if (!path.length) {\n      throw new Error(\"Illegal state\");\n    }\n\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n\n      if (!base || typeof base !== \"object\") {\n        throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      } // prettier-ignore\n\n    }\n\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        if (isMap(base)) {\n          base.set(key, value);\n        } else if (isSet(base)) {\n          throw new Error('Sets cannot have \"replace\" patches.');\n        } else {\n          // if value is an object, then it's assigned by reference\n          // in the following add or remove ops, the value field inside the patch will also be modifyed\n          // so we use value from the cloned patch\n          base[key] = value;\n        }\n\n        break;\n\n      case \"add\":\n        if (isSet(base)) {\n          base.delete(patch.value);\n        }\n\n        Array.isArray(base) ? base.splice(key, 0, value) : isMap(base) ? base.set(key, value) : isSet(base) ? base.add(value) : base[key] = value;\n        break;\n\n      case \"remove\":\n        Array.isArray(base) ? base.splice(key, 1) : isMap(base) ? base.delete(key) : isSet(base) ? base.delete(patch.value) : delete base[key];\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n  this.produceWithPatches = this.produceWithPatches.bind(this);\n};\n\nImmer.prototype.produce = function produce(base, recipe, patchListener) {\n  var this$1 = this; // curried invocation\n\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n      var this$1 = this;\n      if (base === void 0) base = defaultBase;\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        args[len] = arguments[len + 1];\n      }\n\n      return self.produce(base, function (draft) {\n        return recipe.call.apply(recipe, [this$1, draft].concat(args));\n      }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) {\n        scope.revoke();\n      } else {\n        scope.leave();\n      }\n    }\n\n    if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n\n    if (result === NOTHING) {\n      return undefined;\n    }\n\n    if (result === undefined) {\n      result = base;\n    }\n\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches(arg1, arg2, arg3) {\n  var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        args[len] = arguments[len + 1];\n      }\n\n      return this$1.produceWithPatches(state, function (draft) {\n        return arg1.apply(void 0, [draft].concat(args));\n      });\n    };\n  } // non-curried form\n\n\n  if (arg3) {\n    throw new Error(\"A patch listener cannot be passed to produceWithPatches\");\n  }\n\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft(base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft(draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze(value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies(value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1(base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) {\n    return applyPatches(draft, patches.slice(i + 1));\n  });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult(result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize(draft, path, scope) {\n  var this$1 = this;\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) {\n      return draft;\n    }\n\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (this.onDelete && !isSet(state.base)) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      } else {\n        // TODO: Figure it out for Maps and Sets if we need to support ES5\n        var base = state.base;\n        var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree(root, rootPath, scope) {\n  var this$1 = this;\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function finalizeProperty(prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n    var isSetMember = isSet(parent);\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !isSetMember && // Set objects are atomic since they have no keys.\n      !has(state.assigned, prop) // Skip deep patches for assigned keys.\n      ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope);\n      replace(parent, prop, value); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === get(state.base, prop)) {\n        return;\n      }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, get(state.base, prop))) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign && !isSetMember) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze(value, deep) {\n  if (deep === void 0) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n};\n\nfunction replace(parent, prop, value) {\n  if (isMap(parent)) {\n    parent.set(prop, value);\n  } else if (isSet(parent)) {\n    // In this case, the `prop` is actually a draft.\n    parent.delete(prop);\n    parent.add(value);\n  } else if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n    // Preserve non-enumerable properties.\n    parent[prop] = value;\n  } else {\n    Object.defineProperty(parent, prop, {\n      value: value,\n      writable: true,\n      configurable: true\n    });\n  }\n}\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","// shim for using process in browser\nvar process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');\n}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');\n}\n\n(function () {\n  try {\n    if (typeof setTimeout === 'function') {\n      cachedSetTimeout = setTimeout;\n    } else {\n      cachedSetTimeout = defaultSetTimout;\n    }\n  } catch (e) {\n    cachedSetTimeout = defaultSetTimout;\n  }\n\n  try {\n    if (typeof clearTimeout === 'function') {\n      cachedClearTimeout = clearTimeout;\n    } else {\n      cachedClearTimeout = defaultClearTimeout;\n    }\n  } catch (e) {\n    cachedClearTimeout = defaultClearTimeout;\n  }\n})();\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {\n    //normal enviroments in sane situations\n    return setTimeout(fun, 0);\n  } // if setTimeout wasn't available but was latter defined\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedSetTimeout(fun, 0);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n      return cachedSetTimeout.call(null, fun, 0);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n      return cachedSetTimeout.call(this, fun, 0);\n    }\n  }\n}\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {\n    //normal enviroments in sane situations\n    return clearTimeout(marker);\n  } // if clearTimeout wasn't available but was latter defined\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);\n  }\n\n  try {\n    // when when somebody has screwed with setTimeout but no I.E. maddness\n    return cachedClearTimeout(marker);\n  } catch (e) {\n    try {\n      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n      return cachedClearTimeout.call(null, marker);\n    } catch (e) {\n      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n      // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n      return cachedClearTimeout.call(this, marker);\n    }\n  }\n}\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n\n  draining = false;\n\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n\n  if (queue.length) {\n    drainQueue();\n  }\n}\n\nfunction drainQueue() {\n  if (draining) {\n    return;\n  }\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n  var len = queue.length;\n\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();\n      }\n    }\n\n    queueIndex = -1;\n    len = queue.length;\n  }\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n  var args = new Array(arguments.length - 1);\n\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  queue.push(new Item(fun, args));\n\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);\n  }\n}; // v8 likes predictible objects\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) {\n  return [];\n};\n\nprocess.binding = function (name) {\n  throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () {\n  return '/';\n};\n\nprocess.chdir = function (dir) {\n  throw new Error('process.chdir is not supported');\n};\n\nprocess.umask = function () {\n  return 0;\n};"],"sourceRoot":""}